"use strict";(self.webpackChunkmichelson_sdk_docs=self.webpackChunkmichelson_sdk_docs||[]).push([[460],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var l=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,l)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,l,i=function(e,t){if(null==e)return{};var n,l,i={},a=Object.keys(e);for(l=0;l<a.length;l++)n=a[l],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(l=0;l<a.length;l++)n=a[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=l.createContext({}),p=function(e){var t=l.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return l.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},m=l.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(n),h=i,u=m["".concat(s,".").concat(h)]||m[h]||d[h]||a;return n?l.createElement(u,r(r({ref:t},c),{},{components:n})):l.createElement(u,r({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var p=2;p<a;p++)r[p]=n[p];return l.createElement.apply(null,r)}return l.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3532:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return m}});var l=n(7462),i=n(3366),a=(n(7294),n(3905)),r=["components"],o={},s="Type Reference",p={unversionedId:"types",id:"types",title:"Type Reference",description:"Official Michelson type reference",source:"@site/docs/types.md",sourceDirName:".",slug:"/types",permalink:"/michelson-sdk/types",editUrl:"https://github.com/RomarQ/michelson-sdk/tree/main/documentation/docs/types.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Overview",permalink:"/michelson-sdk/"},next:{title:"Value Reference",permalink:"/michelson-sdk/values"}},c=[{value:"Singleton types",id:"singleton-types",children:[{value:"nat",id:"nat",children:[],level:3},{value:"int",id:"int",children:[],level:3},{value:"mutez",id:"mutez",children:[],level:3},{value:"string",id:"string",children:[],level:3},{value:"bool",id:"bool",children:[],level:3},{value:"bytes",id:"bytes",children:[],level:3},{value:"address",id:"address",children:[],level:3},{value:"timestamp",id:"timestamp",children:[],level:3},{value:"chain_id",id:"chain_id",children:[],level:3},{value:"bls12_381_fr",id:"bls12_381_fr",children:[],level:3},{value:"bls12_381_g1",id:"bls12_381_g1",children:[],level:3},{value:"bls12_381_g2",id:"bls12_381_g2",children:[],level:3},{value:"key",id:"key",children:[],level:3},{value:"key_hash",id:"key_hash",children:[],level:3},{value:"signature",id:"signature",children:[],level:3},{value:"unit",id:"unit",children:[],level:3}],level:2},{value:"Container types",id:"container-types",children:[{value:"list",id:"list",children:[],level:3},{value:"set",id:"set",children:[],level:3},{value:"option",id:"option",children:[],level:3},{value:"pair",id:"pair",children:[],level:3},{value:"or",id:"or",children:[],level:3},{value:"map",id:"map",children:[],level:3},{value:"big_map",id:"big_map",children:[],level:3},{value:"lambda",id:"lambda",children:[],level:3},{value:"record",id:"record",children:[],level:3},{value:"variant",id:"variant",children:[],level:3},{value:"ticket",id:"ticket",children:[],level:3},{value:"sapling_state",id:"sapling_state",children:[],level:3},{value:"sapling_transaction",id:"sapling_transaction",children:[],level:3},{value:"contract type",id:"contract-type",children:[],level:3},{value:"operation",id:"operation",children:[],level:3}],level:2}],d={toc:c};function m(e){var t=e.components,n=(0,i.Z)(e,r);return(0,a.kt)("wrapper",(0,l.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"type-reference"},"Type Reference"),(0,a.kt)("p",null,"Official ",(0,a.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/michelson-reference/#type-reference"},"Michelson type reference")),(0,a.kt)("h2",{id:"singleton-types"},"Singleton types"),(0,a.kt)("h3",{id:"nat"},"nat"),(0,a.kt)("p",null,"Naturals are arbitrary-precision, meaning that the only size limit is gas."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TNat } from '@tezwell/michelson-sdk';\n\nconst nat_type = TNat();\n\n// Micheline\nconsole.log(nat_type.toMicheline());      // nat\n// JSON\nconsole.log(nat_type.toJSON());           // { prim: 'nat' }\n")),(0,a.kt)("h3",{id:"int"},"int"),(0,a.kt)("p",null,"Integers are arbitrary-precision, meaning that the only size limit is gas."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TInt } from '@tezwell/michelson-sdk';\n\nconst int_type = TInt();\n\n// Micheline\nconsole.log(int_type.toMicheline());      // int\n// JSON\nconsole.log(int_type.toJSON());           // { prim: 'int' }\n")),(0,a.kt)("h3",{id:"mutez"},"mutez"),(0,a.kt)("p",null,"Mutez (micro-Tez) are internally represented by ",(0,a.kt)("strong",{parentName:"p"},"64-bit")," signed integers. These are restricted to prevent creating a negative amount of mutez."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TMutez } from '@tezwell/michelson-sdk';\n\nconst mutez_type = TMutez();\n\n// Micheline\nconsole.log(mutez_type.toMicheline());      // mutez\n// JSON\nconsole.log(mutez_type.toJSON());           // { prim: 'mutez' }\n")),(0,a.kt)("h3",{id:"string"},"string"),(0,a.kt)("p",null,"The current version of Michelson restricts strings to be the printable subset of ",(0,a.kt)("strong",{parentName:"p"},"7-bit ASCII"),", namely characters with codes from within ","[32, 126]"," range, plus the following escape characters ",(0,a.kt)("inlineCode",{parentName:"p"},"\\n"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"\\\\"),", ",(0,a.kt)("inlineCode",{parentName:"p"},'\\"'),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TString } from '@tezwell/michelson-sdk';\n\nconst string_type = TString();\n\n// Micheline\nconsole.log(string_type.toMicheline());      // string\n// JSON\nconsole.log(string_type.toJSON());           // { prim: 'string' }\n")),(0,a.kt)("h3",{id:"bool"},"bool"),(0,a.kt)("p",null,"The type for booleans whose values are ",(0,a.kt)("inlineCode",{parentName:"p"},"True")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"False"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TBool } from '@tezwell/michelson-sdk';\n\nconst bool_type = TBool();\n\n// Micheline\nconsole.log(bool_type.toMicheline());      // bool\n// JSON\nconsole.log(bool_type.toJSON());           // { prim: 'bool' }\n")),(0,a.kt)("h3",{id:"bytes"},"bytes"),(0,a.kt)("p",null,"Bytes are used for serializing data, in order to check signatures and compute hashes on them. They can also be used to incorporate data from the wild and untyped outside world."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TBytes } from '@tezwell/michelson-sdk';\n\nconst bytes_type = TBytes();\n\n// Micheline\nconsole.log(bytes_type.toMicheline());      // bytes\n// JSON\nconsole.log(bytes_type.toJSON());           // { prim: 'bytes' }\n")),(0,a.kt)("h3",{id:"address"},"address"),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"address")," gives the guarantee that the value has the form of a Tezos address, as opposed to contract that guarantees that the value is indeed a valid, existing account."),(0,a.kt)("p",null,"A valid Tezos address is a string prefixed by either ",(0,a.kt)("inlineCode",{parentName:"p"},"tz1"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"tz2"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"tz3")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"KT1")," and followed by a Base58 encoded hash and terminated by a 4-byte checksum."),(0,a.kt)("p",null,"The prefix designates the type of address:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"tz1"))," addresses are followed by a ed25519 public key hash"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"tz2"))," addresses are followed by a Secp256k1 public key hash"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"tz3"))," addresses are followed by a NIST p256r1 public key hash"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"KT1"))," addresses are followed by a contract hash")),(0,a.kt)("p",null,"Addresses prefixed by tz1, tz2 and tz3 designate implicit accounts, whereas those prefixed KT1 designate originated accounts."),(0,a.kt)("p",null,"Addresses can also specify an entrypoint, with a ",(0,a.kt)("inlineCode",{parentName:"p"},"%<entrypoint_name>")," suffix."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TAddress } from '@tezwell/michelson-sdk';\n\nconst address_type = TAddress();\n\n// Micheline\nconsole.log(address_type.toMicheline());      // address\n// JSON\nconsole.log(address_type.toJSON());           // { prim: 'address' }\n")),(0,a.kt)("h3",{id:"timestamp"},"timestamp"),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"timestamp")," is used to represent timestamps that are written either using ",(0,a.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc3339"},"RFC3339")," notation in a string (readable), or as the number of seconds since Epoch in a natural (optimized)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TTimestamp } from '@tezwell/michelson-sdk';\n\nconst timestamp_type = TTimestamp();\n\n// Micheline\nconsole.log(timestamp_type.toMicheline());      // timestamp\n// JSON\nconsole.log(timestamp_type.toJSON());           // { prim: 'timestamp' }\n")),(0,a.kt)("h3",{id:"chain_id"},"chain_id"),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"chain_id")," represents an identifier for a chain, used to distinguish the test and the main chains."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TChain_id } from '@tezwell/michelson-sdk';\n\nconst chain_id_type = TChain_id();\n\n// Micheline\nconsole.log(chain_id_type.toMicheline());      // chain_id\n// JSON\nconsole.log(chain_id_type.toJSON());           // { prim: 'chain_id' }\n")),(0,a.kt)("h3",{id:"bls12_381_fr"},"bls12_381_fr"),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"bls12_381_fr")," represents an element of the scalar field Fr, used for scalar multiplication on the BLS12-381 curves G1 and G2."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TBls12_381_fr } from '@tezwell/michelson-sdk';\n\nconst bls12_381_fr_type = TBls12_381_fr();\n\n// Micheline\nconsole.log(bls12_381_fr_type.toMicheline());      // bls12_381_fr\n// JSON\nconsole.log(bls12_381_fr_type.toJSON());           // { prim: 'bls12_381_fr' }\n")),(0,a.kt)("h3",{id:"bls12_381_g1"},"bls12_381_g1"),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"bls12_381_g1")," represents a point on the BLS12-381 curve G1."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TBls12_381_g1 } from '@tezwell/michelson-sdk';\n\nconst bls12_381_g1_type = TBls12_381_g1();\n\n// Micheline\nconsole.log(bls12_381_g1_type.toMicheline());      // bls12_381_g1\n// JSON\nconsole.log(bls12_381_g1_type.toJSON());           // { prim: 'bls12_381_g1' }\n")),(0,a.kt)("h3",{id:"bls12_381_g2"},"bls12_381_g2"),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"bls12_381_g2")," represents a point on the BLS12-381 curve G2."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TBls12_381_g2 } from '@tezwell/michelson-sdk';\n\nconst bls12_381_g2_type = TBls12_381_g2();\n\n// Micheline\nconsole.log(bls12_381_g2_type.toMicheline());      // bls12_381_g2\n// JSON\nconsole.log(bls12_381_g2_type.toJSON());           // { prim: 'bls12_381_g2' }\n")),(0,a.kt)("h3",{id:"key"},"key"),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," represents a public cryptographic key."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TKey } from '@tezwell/michelson-sdk';\n\nconst key_type = TKey();\n\n// Micheline\nconsole.log(key_type.toMicheline());      // key\n// JSON\nconsole.log(key_type.toJSON());           // { prim: 'key' }\n")),(0,a.kt)("h3",{id:"key_hash"},"key_hash"),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"key_hash")," represents a hash of a public cryptographic key."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TKey_hash } from '@tezwell/michelson-sdk';\n\nconst key_hash_type = TKey_hash();\n\n// Micheline\nconsole.log(key_hash_type.toMicheline());      // key_hash\n// JSON\nconsole.log(key_hash_type.toJSON());           // { prim: 'key_hash' }\n")),(0,a.kt)("h3",{id:"signature"},"signature"),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"signature")," represents a cryptographic signature."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TSignature } from '@tezwell/michelson-sdk';\n\nconst signature_type = TSignature();\n\n// Micheline\nconsole.log(signature_type.toMicheline());      // signature\n// JSON\nconsole.log(signature_type.toJSON());           // { prim: 'signature' }\n")),(0,a.kt)("h3",{id:"unit"},"unit"),(0,a.kt)("p",null,"The type whose only value is Unit, to use as a placeholder when some result or parameter is non-necessary."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TUnit } from '@tezwell/michelson-sdk';\n\nconst unit_type = TUnit();\n\n// Micheline\nconsole.log(unit_type.toMicheline());      // unit\n// JSON\nconsole.log(unit_type.toJSON());           // { prim: 'unit' }\n")),(0,a.kt)("h2",{id:"container-types"},"Container types"),(0,a.kt)("h3",{id:"list"},"list"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"list")," type reprensents a immutable and homogeneous linked list."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TList, TNat } from '@tezwell/michelson-sdk';\n\nconst list_type = TList(TNat());\n\n// Micheline\nconsole.log(list_type.toMicheline());      // (list nat)\n// JSON\nconsole.log(list_type.toJSON());           // { prim: 'list', args: [ { prim: 'nat' } ] }\n")),(0,a.kt)("h3",{id:"set"},"set"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"set")," type is used to represent sequences of unique elements."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TSet, TNat } from '@tezwell/michelson-sdk';\n\nconst set_type = TSet(TNat());\n\n// Micheline\nconsole.log(set_type.toMicheline());      // (set nat)\n// JSON\nconsole.log(set_type.toJSON());           // { prim: 'set', args: [ { prim: 'nat' } ] }\n")),(0,a.kt)("h3",{id:"option"},"option"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"option")," type is used to represent an optional value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TOption, TNat } from '@tezwell/michelson-sdk';\n\nconst option_type = TOption(TNat());\n\n// Micheline\nconsole.log(option_type.toMicheline());      // (option nat)\n// JSON\nconsole.log(option_type.toJSON());           // { prim: 'option', args: [ { prim: 'nat' } ] }\n")),(0,a.kt)("h3",{id:"pair"},"pair"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"pair")," type represents a binary tuple composed of a left element and a right element."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TPair, TNat, TString } from '@tezwell/michelson-sdk';\n\nconst pair_type = TPair(TString(), TNat());\n\n// Micheline\nconsole.log(pair_type.toMicheline());      // (pair string nat)\n// JSON\nconsole.log(pair_type.toJSON());           // { prim: 'pair', args: [ { prim: 'string' }, { prim: 'nat' } ] }\n")),(0,a.kt)("h3",{id:"or"},"or"),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"or")," represents a union of two types. Used for type variance. (e.g. number | string)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { TOr, TNat, TString } from '@tezwell/michelson-sdk';\n\nconst or_type = TOr(TString(), TNat());\n\n// Micheline\nconsole.log(or_type.toMicheline());      // (or string nat)\n// JSON\nconsole.log(or_type.toJSON());           // { prim: 'or', args: [ { prim: 'string' }, { prim: 'nat' } ] }\n")),(0,a.kt)("h3",{id:"map"},"map"),(0,a.kt)("h3",{id:"big_map"},"big_map"),(0,a.kt)("h3",{id:"lambda"},"lambda"),(0,a.kt)("h3",{id:"record"},"record"),(0,a.kt)("h3",{id:"variant"},"variant"),(0,a.kt)("h3",{id:"ticket"},"ticket"),(0,a.kt)("p",null,"Tickets are a way for smart contracts to authenticate data with respect to a Tezos address. This authentication can then be used to build composable permission systems."),(0,a.kt)("p",null,"A contract can create a ticket from a comparable value and an amount. The ticket, when inspected, reveals the value, the amount, and the address of the ticketer (the contract that created the ticket). It is impossible for a contract to \u201cforge\u201d a ticket that appears to have been created by another ticketer."),(0,a.kt)("p",null,"The amount is a metadata that can be used to implement UTXOs."),(0,a.kt)("p",null,"Tickets cannot be duplicated using the DUP instruction."),(0,a.kt)("p",null,"For example, a ticket could represent a Non-Fungible Token (NFT) or a Unspent Transaction Output (UTXO) which can then be passed around and behave like a value. This process can happen without the need to interact with a centralized NFT contract, simplifying the code."),(0,a.kt)("h3",{id:"sapling_state"},"sapling_state"),(0,a.kt)("h3",{id:"sapling_transaction"},"sapling_transaction"),(0,a.kt)("h3",{id:"contract-type"},"contract type"),(0,a.kt)("h3",{id:"operation"},"operation"))}m.isMDXComponent=!0}}]);