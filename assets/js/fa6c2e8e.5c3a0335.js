"use strict";(self.webpackChunkmichelson_sdk_docs=self.webpackChunkmichelson_sdk_docs||[]).push([[460],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return h}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),p=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=p(e.components);return i.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},d=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(t),h=a,g=d["".concat(s,".").concat(h)]||d[h]||m[h]||l;return t?i.createElement(g,r(r({ref:n},c),{},{components:t})):i.createElement(g,r({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,r=new Array(l);r[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var p=2;p<l;p++)r[p]=t[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3532:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return d}});var i=t(7462),a=t(3366),l=(t(7294),t(3905)),r=["components"],o={},s="Type Reference",p={unversionedId:"types",id:"types",title:"Type Reference",description:"Official Michelson type reference",source:"@site/docs/types.md",sourceDirName:".",slug:"/types",permalink:"/michelson-sdk/types",editUrl:"https://github.com/RomarQ/michelson-sdk/tree/main/documentation/docs/types.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Overview",permalink:"/michelson-sdk/"},next:{title:"Value Reference",permalink:"/michelson-sdk/values"}},c=[{value:"Singleton types",id:"singleton-types",children:[{value:"nat",id:"nat",children:[],level:3},{value:"int",id:"int",children:[],level:3},{value:"mutez",id:"mutez",children:[],level:3},{value:"string",id:"string",children:[],level:3},{value:"bool",id:"bool",children:[],level:3},{value:"bytes",id:"bytes",children:[],level:3},{value:"address",id:"address",children:[],level:3},{value:"timestamp",id:"timestamp",children:[],level:3},{value:"chain_id",id:"chain_id",children:[],level:3},{value:"bls12_381_fr",id:"bls12_381_fr",children:[],level:3},{value:"bls12_381_g1",id:"bls12_381_g1",children:[],level:3},{value:"bls12_381_g2",id:"bls12_381_g2",children:[],level:3},{value:"key",id:"key",children:[],level:3},{value:"key_hash",id:"key_hash",children:[],level:3},{value:"signature",id:"signature",children:[],level:3},{value:"unit",id:"unit",children:[],level:3},{value:"operation",id:"operation",children:[],level:3},{value:"never",id:"never",children:[],level:3}],level:2},{value:"Container types",id:"container-types",children:[{value:"list",id:"list",children:[],level:3},{value:"set",id:"set",children:[],level:3},{value:"option",id:"option",children:[],level:3},{value:"pair",id:"pair",children:[],level:3},{value:"or",id:"or",children:[],level:3},{value:"map",id:"map",children:[],level:3},{value:"big_map",id:"big_map",children:[],level:3},{value:"lambda",id:"lambda",children:[],level:3},{value:"ticket",id:"ticket",children:[],level:3},{value:"contract",id:"contract",children:[],level:3},{value:"sapling_state",id:"sapling_state",children:[],level:3},{value:"sapling_transaction",id:"sapling_transaction",children:[],level:3}],level:2},{value:"Artificial types",id:"artificial-types",children:[{value:"record",id:"record",children:[],level:3},{value:"variant",id:"variant",children:[],level:3}],level:2}],m={toc:c};function d(e){var n=e.components,t=(0,a.Z)(e,r);return(0,l.kt)("wrapper",(0,i.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"type-reference"},"Type Reference"),(0,l.kt)("p",null,"Official ",(0,l.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/michelson-reference/#type-reference"},"Michelson type reference")),(0,l.kt)("h2",{id:"singleton-types"},"Singleton types"),(0,l.kt)("h3",{id:"nat"},"nat"),(0,l.kt)("p",null,"Naturals are arbitrary-precision, meaning that the only size limit is gas."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TNat } from '@tezwell/michelson-sdk';\n\nconst nat_type = TNat();\n\n// Micheline\nconsole.log(nat_type.toMicheline());      // nat\n// JSON\nconsole.log(nat_type.toJSON());           // { prim: 'nat' }\n")),(0,l.kt)("h3",{id:"int"},"int"),(0,l.kt)("p",null,"Integers are arbitrary-precision, meaning that the only size limit is gas."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TInt } from '@tezwell/michelson-sdk';\n\nconst int_type = TInt();\n\n// Micheline\nconsole.log(int_type.toMicheline());      // int\n// JSON\nconsole.log(int_type.toJSON());           // { prim: 'int' }\n")),(0,l.kt)("h3",{id:"mutez"},"mutez"),(0,l.kt)("p",null,"Mutez (micro-Tez) are internally represented by ",(0,l.kt)("strong",{parentName:"p"},"64-bit")," signed integers. These are restricted to prevent creating a negative amount of mutez."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TMutez } from '@tezwell/michelson-sdk';\n\nconst mutez_type = TMutez();\n\n// Micheline\nconsole.log(mutez_type.toMicheline());      // mutez\n// JSON\nconsole.log(mutez_type.toJSON());           // { prim: 'mutez' }\n")),(0,l.kt)("h3",{id:"string"},"string"),(0,l.kt)("p",null,"The current version of Michelson restricts strings to be the printable subset of ",(0,l.kt)("strong",{parentName:"p"},"7-bit ASCII"),", namely characters with codes from within ","[32, 126]"," range, plus the following escape characters ",(0,l.kt)("inlineCode",{parentName:"p"},"\\n"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"\\\\"),", ",(0,l.kt)("inlineCode",{parentName:"p"},'\\"'),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TString } from '@tezwell/michelson-sdk';\n\nconst string_type = TString();\n\n// Micheline\nconsole.log(string_type.toMicheline());      // string\n// JSON\nconsole.log(string_type.toJSON());           // { prim: 'string' }\n")),(0,l.kt)("h3",{id:"bool"},"bool"),(0,l.kt)("p",null,"The type for booleans whose values are ",(0,l.kt)("inlineCode",{parentName:"p"},"True")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"False"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TBool } from '@tezwell/michelson-sdk';\n\nconst bool_type = TBool();\n\n// Micheline\nconsole.log(bool_type.toMicheline());      // bool\n// JSON\nconsole.log(bool_type.toJSON());           // { prim: 'bool' }\n")),(0,l.kt)("h3",{id:"bytes"},"bytes"),(0,l.kt)("p",null,"Bytes are used for serializing data, in order to check signatures and compute hashes on them. They can also be used to incorporate data from the wild and untyped outside world."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TBytes } from '@tezwell/michelson-sdk';\n\nconst bytes_type = TBytes();\n\n// Micheline\nconsole.log(bytes_type.toMicheline());      // bytes\n// JSON\nconsole.log(bytes_type.toJSON());           // { prim: 'bytes' }\n")),(0,l.kt)("h3",{id:"address"},"address"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"address")," gives the guarantee that the value has the form of a Tezos address, as opposed to contract that guarantees that the value is indeed a valid, existing account."),(0,l.kt)("p",null,"A valid Tezos address is a string prefixed by either ",(0,l.kt)("inlineCode",{parentName:"p"},"tz1"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"tz2"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"tz3")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"KT1")," and followed by a Base58 encoded hash and terminated by a 4-byte checksum."),(0,l.kt)("p",null,"The prefix designates the type of address:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"tz1"))," addresses are followed by a ed25519 public key hash"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"tz2"))," addresses are followed by a Secp256k1 public key hash"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"tz3"))," addresses are followed by a NIST p256r1 public key hash"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"strong"},"KT1"))," addresses are followed by a contract hash")),(0,l.kt)("p",null,"Addresses prefixed by tz1, tz2 and tz3 designate implicit accounts, whereas those prefixed KT1 designate originated accounts."),(0,l.kt)("p",null,"Addresses can also specify an entrypoint, with a ",(0,l.kt)("inlineCode",{parentName:"p"},"%<entrypoint_name>")," suffix."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TAddress } from '@tezwell/michelson-sdk';\n\nconst address_type = TAddress();\n\n// Micheline\nconsole.log(address_type.toMicheline());      // address\n// JSON\nconsole.log(address_type.toJSON());           // { prim: 'address' }\n")),(0,l.kt)("h3",{id:"timestamp"},"timestamp"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"timestamp")," is used to represent timestamps that are written either using ",(0,l.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc3339"},"RFC3339")," notation in a string (readable), or as the number of seconds since Epoch in a natural (optimized)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TTimestamp } from '@tezwell/michelson-sdk';\n\nconst timestamp_type = TTimestamp();\n\n// Micheline\nconsole.log(timestamp_type.toMicheline());      // timestamp\n// JSON\nconsole.log(timestamp_type.toJSON());           // { prim: 'timestamp' }\n")),(0,l.kt)("h3",{id:"chain_id"},"chain_id"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"chain_id")," represents an identifier for a chain, used to distinguish the test and the main chains."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TChain_id } from '@tezwell/michelson-sdk';\n\nconst chain_id_type = TChain_id();\n\n// Micheline\nconsole.log(chain_id_type.toMicheline());      // chain_id\n// JSON\nconsole.log(chain_id_type.toJSON());           // { prim: 'chain_id' }\n")),(0,l.kt)("h3",{id:"bls12_381_fr"},"bls12_381_fr"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"bls12_381_fr")," represents an element of the scalar field Fr, used for scalar multiplication on the BLS12-381 curves G1 and G2."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TBls12_381_fr } from '@tezwell/michelson-sdk';\n\nconst bls12_381_fr_type = TBls12_381_fr();\n\n// Micheline\nconsole.log(bls12_381_fr_type.toMicheline());      // bls12_381_fr\n// JSON\nconsole.log(bls12_381_fr_type.toJSON());           // { prim: 'bls12_381_fr' }\n")),(0,l.kt)("h3",{id:"bls12_381_g1"},"bls12_381_g1"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"bls12_381_g1")," represents a point on the BLS12-381 curve G1."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TBls12_381_g1 } from '@tezwell/michelson-sdk';\n\nconst bls12_381_g1_type = TBls12_381_g1();\n\n// Micheline\nconsole.log(bls12_381_g1_type.toMicheline());      // bls12_381_g1\n// JSON\nconsole.log(bls12_381_g1_type.toJSON());           // { prim: 'bls12_381_g1' }\n")),(0,l.kt)("h3",{id:"bls12_381_g2"},"bls12_381_g2"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"bls12_381_g2")," represents a point on the BLS12-381 curve G2."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TBls12_381_g2 } from '@tezwell/michelson-sdk';\n\nconst bls12_381_g2_type = TBls12_381_g2();\n\n// Micheline\nconsole.log(bls12_381_g2_type.toMicheline());      // bls12_381_g2\n// JSON\nconsole.log(bls12_381_g2_type.toJSON());           // { prim: 'bls12_381_g2' }\n")),(0,l.kt)("h3",{id:"key"},"key"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," represents a public cryptographic key."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TKey } from '@tezwell/michelson-sdk';\n\nconst key_type = TKey();\n\n// Micheline\nconsole.log(key_type.toMicheline());      // key\n// JSON\nconsole.log(key_type.toJSON());           // { prim: 'key' }\n")),(0,l.kt)("h3",{id:"key_hash"},"key_hash"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"key_hash")," represents a hash of a public cryptographic key."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TKey_hash } from '@tezwell/michelson-sdk';\n\nconst key_hash_type = TKey_hash();\n\n// Micheline\nconsole.log(key_hash_type.toMicheline());      // key_hash\n// JSON\nconsole.log(key_hash_type.toJSON());           // { prim: 'key_hash' }\n")),(0,l.kt)("h3",{id:"signature"},"signature"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"signature")," represents a cryptographic signature."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TSignature } from '@tezwell/michelson-sdk';\n\nconst signature_type = TSignature();\n\n// Micheline\nconsole.log(signature_type.toMicheline());      // signature\n// JSON\nconsole.log(signature_type.toJSON());           // { prim: 'signature' }\n")),(0,l.kt)("h3",{id:"unit"},"unit"),(0,l.kt)("p",null,"The type whose only value is Unit, to use as a placeholder when some result or parameter is non-necessary."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TUnit } from '@tezwell/michelson-sdk';\n\nconst unit_type = TUnit();\n\n// Micheline\nconsole.log(unit_type.toMicheline());      // unit\n// JSON\nconsole.log(unit_type.toJSON());           // { prim: 'unit' }\n")),(0,l.kt)("h3",{id:"operation"},"operation"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"operation")," represents an internal operation emitted by a contract."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TOperation } from '@tezwell/michelson-sdk';\n\nconst operation_type = TOperation();\n\n// Micheline\nconsole.log(operation_type.toMicheline());      // operation\n// JSON\nconsole.log(operation_type.toJSON());           // { prim: 'operation' }\n")),(0,l.kt)("h3",{id:"never"},"never"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"never")," is used to represent an unreachable branch."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TNever } from '@tezwell/michelson-sdk';\n\nconst never_type = TNever();\n\n// Micheline\nconsole.log(never_type.toMicheline());      // never\n// JSON\nconsole.log(never_type.toJSON());           // { prim: 'never' }\n")),(0,l.kt)("h2",{id:"container-types"},"Container types"),(0,l.kt)("h3",{id:"list"},"list"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," type reprensents a immutable and homogeneous linked list."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TList, TNat } from '@tezwell/michelson-sdk';\n\nconst list_type = TList(TNat());\n\n// Micheline\nconsole.log(list_type.toMicheline());      // (list nat)\n// JSON\nconsole.log(list_type.toJSON());           // { prim: 'list', args: [ { prim: 'nat' } ] }\n")),(0,l.kt)("h3",{id:"set"},"set"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"set")," type is used to represent sequences of unique elements."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TSet, TNat } from '@tezwell/michelson-sdk';\n\nconst set_type = TSet(TNat());\n\n// Micheline\nconsole.log(set_type.toMicheline());      // (set nat)\n// JSON\nconsole.log(set_type.toJSON());           // { prim: 'set', args: [ { prim: 'nat' } ] }\n")),(0,l.kt)("h3",{id:"option"},"option"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"option")," type is used to represent an optional value."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TOption, TNat } from '@tezwell/michelson-sdk';\n\nconst option_type = TOption(TNat());\n\n// Micheline\nconsole.log(option_type.toMicheline());      // (option nat)\n// JSON\nconsole.log(option_type.toJSON());           // { prim: 'option', args: [ { prim: 'nat' } ] }\n")),(0,l.kt)("h3",{id:"pair"},"pair"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"pair")," type represents a binary tuple composed of a left element and a right element."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TPair, TNat, TString } from '@tezwell/michelson-sdk';\n\nconst pair_type = TPair(TString(), TNat());\n\n// Micheline\nconsole.log(pair_type.toMicheline());      // (pair string nat)\n// JSON\nconsole.log(pair_type.toJSON());           // { prim: 'pair', args: [ { prim: 'string' }, { prim: 'nat' } ] }\n")),(0,l.kt)("h3",{id:"or"},"or"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"or")," represents a union of two types. Used for type variance. (e.g. number | string)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TOr, TNat, TString } from '@tezwell/michelson-sdk';\n\nconst or_type = TOr(TString(), TNat());\n\n// Micheline\nconsole.log(or_type.toMicheline());      // (or string nat)\n// JSON\nconsole.log(or_type.toJSON());           // { prim: 'or', args: [ { prim: 'string' }, { prim: 'nat' } ] }\n")),(0,l.kt)("h3",{id:"map"},"map"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TMap, TNat, TString } from '@tezwell/michelson-sdk';\n\nconst map_type = TMap(TString(), TNat());\n\n// Micheline\nconsole.log(map_type.toMicheline());      // (map string nat)\n// JSON\nconsole.log(map_type.toJSON());           // { prim: 'map', args: [ { prim: 'string' }, { prim: 'nat' } ] }\n")),(0,l.kt)("h3",{id:"big_map"},"big_map"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"big_map")," is used to represent lazily deserialized maps."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TBigMap, TNat, TString } from '@tezwell/michelson-sdk';\n\nconst big_map_type = TBigMap(TString(), TNat());\n\n// Micheline\nconsole.log(big_map_type.toMicheline());      // (big_map string nat)\n// JSON\nconsole.log(big_map_type.toJSON());           // { prim: 'big_map', args: [ { prim: 'string' }, { prim: 'nat' } ] }\n")),(0,l.kt)("h3",{id:"lambda"},"lambda"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"lambda")," represents a function signature."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TLambda, TNat, TString } from '@tezwell/michelson-sdk';\n\nconst lambda_type = TLambda(TString(), TNat());\n\n// Micheline\nconsole.log(lambda_type.toMicheline());      // (lambda string nat)\n// JSON\nconsole.log(lambda_type.toJSON());           // { prim: 'lambda', args: [ { prim: 'string' }, { prim: 'nat' } ] }\n")),(0,l.kt)("h3",{id:"ticket"},"ticket"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"ticket")," represents a ticket used to authenticate information."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TTicket, TString } from '@tezwell/michelson-sdk';\n\nconst ticket_type = TTicket(TString());\n\n// Micheline\nconsole.log(ticket_type.toMicheline());      // (ticket string)\n// JSON\nconsole.log(ticket_type.toJSON());           // { prim: 'ticket', args: [ { prim: 'string' } ] }\n")),(0,l.kt)("h3",{id:"contract"},"contract"),(0,l.kt)("p",null,"The type ",(0,l.kt)("inlineCode",{parentName:"p"},"contract")," represents the interface and address of a contract entrypoint."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TContract, TString } from '@tezwell/michelson-sdk';\n\nconst contract_type = TContract(TString());\n\n// Micheline\nconsole.log(contract_type.toMicheline());      // (contract string)\n// JSON\nconsole.log(contract_type.toJSON());           // { prim: 'contract', args: [ { prim: 'string' } ] }\n")),(0,l.kt)("h3",{id:"sapling_state"},"sapling_state"),(0,l.kt)("p",null,"Michelson reference ",(0,l.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/michelson-reference/#type-sapling_state"},"sapling_state"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TSapling_state } from '@tezwell/michelson-sdk';\n\nconst sapling_state_type = TSapling_state(8);\n\n// Micheline\nconsole.log(sapling_state_type.toMicheline());      // (sapling_state 8)\n// JSON\nconsole.log(sapling_state_type.toJSON());           // { prim: 'sapling_state', args: [ { int: '8' } ] }\n")),(0,l.kt)("h3",{id:"sapling_transaction"},"sapling_transaction"),(0,l.kt)("p",null,"Michelson reference ",(0,l.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/michelson-reference/#type-sapling_transaction"},"sapling_transaction"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TSapling_transaction } from '@tezwell/michelson-sdk';\n\nconst sapling_transaction_type = TSapling_transaction(8);\n\n// Micheline\nconsole.log(sapling_transaction_type.toMicheline());      // (sapling_transaction 8)\n// JSON\nconsole.log(sapling_transaction_type.toJSON());           // { prim: 'sapling_transaction', args: [ { int: '8' } ] }\n")),(0,l.kt)("h2",{id:"artificial-types"},"Artificial types"),(0,l.kt)("h3",{id:"record"},"record"),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"TRecord")," is an artificial type composed of nested ",(0,l.kt)("inlineCode",{parentName:"p"},"pair's")," with annotated leaves to simulate a dictionary."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TRecord, TNat, TInt, TBytes } from '@tezwell/michelson-sdk';\n\nconst record_type = TRecord(\n    {\n        field1: TNat(),\n        field2: TInt(),\n        field3: TBytes()\n    },\n    // Optional argument (defaults to right combs)\n    [\"field1\", [\"field2\", \"field3\"]]\n);\n\n// Micheline\nconsole.log(record_type.toMicheline());      // (pair (nat %field1) (pair (int %field2) (bytes %field3)))\n// JSON\nconsole.log(record_type.toJSON());           // {\n                                             //     prim: 'pair',\n                                             //     args: [\n                                             //         {\n                                             //             prim: 'nat',\n                                             //             annots: [\"%field1\"]\n                                             //         },\n                                             //         {\n                                             //             prim: 'pair',\n                                             //             args: [\n                                             //                 {\n                                             //                     prim: 'int',\n                                             //                     annots: [\"%field2\"]\n                                             //                 },\n                                             //                 {\n                                             //                     prim: 'bytes',\n                                             //                     annots: [\"%field3\"]\n                                             //                 },\n                                             //             ]\n                                             //         }\n                                             //     ]\n                                             // }\n")),(0,l.kt)("h3",{id:"variant"},"variant"),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"TVariant")," is an artificial type composed of nested ",(0,l.kt)("inlineCode",{parentName:"p"},"or's")," with annotated leaves to create a union type."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"import { TVariant, TNat, TInt, TBytes } from '@tezwell/michelson-sdk';\n\nconst variant_type = TVariant(\n    {\n        branch1: TNat(),\n        branch2: TInt(),\n        branch3: TBytes()\n    },\n    // Optional argument (defaults to right combs)\n    [\"branch1\", [\"branch2\", \"branch3\"]]\n);\n\n// Micheline\nconsole.log(variant_type.toMicheline());      // (or (nat %branch1) (or (int %branch2) (bytes %branch3)))\n// JSON\nconsole.log(variant_type.toJSON());          // {\n                                             //     prim: 'or',\n                                             //     args: [\n                                             //         {\n                                             //             prim: 'nat',\n                                             //             annots: [\"%branch1\"]\n                                             //         },\n                                             //         {\n                                             //             prim: 'or',\n                                             //             args: [\n                                             //                 {\n                                             //                     prim: 'int',\n                                             //                     annots: [\"%branch2\"]\n                                             //                 },\n                                             //                 {\n                                             //                     prim: 'bytes',\n                                             //                     annots: [\"%branch3\"]\n                                             //                 },\n                                             //             ]\n                                             //         }\n                                             //     ]\n                                             // }\n")))}d.isMDXComponent=!0}}]);